import{r as a}from"./index.78e80225.js";import{I as C,R as F,w,h as P,l as I,b as R}from"./jsx-runtime.8bb9ef32.js";import{g as j,b as v}from"./i18nInstance.3f0a4b3a.js";const z=(g,n)=>{const d=a.useRef();return a.useEffect(()=>{d.current=n?d.current:g},[g,n]),d.current};function U(g){let n=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};const{i18n:d}=n,{i18n:E,defaultNS:T}=a.useContext(C)||{},e=d||E||v();if(e&&!e.reportNamespaces&&(e.reportNamespaces=new F),!e){w("You will need to pass in an i18next instance by using initReactI18next");const s=(o,r)=>typeof r=="string"?r:r&&typeof r=="object"&&typeof r.defaultValue=="string"?r.defaultValue:Array.isArray(o)?o[o.length-1]:o,i=[s,{},!1];return i.t=s,i.i18n={},i.ready=!1,i}e.options.react&&e.options.react.wait!==void 0&&w("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");const y={...j(),...e.options.react,...n},{useSuspense:N,keyPrefix:h}=y;let t=g||T||e.options&&e.options.defaultNS;t=typeof t=="string"?[t]:t||["translation"],e.reportNamespaces.addUsedNamespaces&&e.reportNamespaces.addUsedNamespaces(t);const f=(e.isInitialized||e.initializedStoreOnce)&&t.every(s=>P(s,e,y));function u(){return e.getFixedT(n.lng||null,y.nsMode==="fallback"?t:t[0],h)}const[x,p]=a.useState(u);let l=t.join();n.lng&&(l=`${n.lng}${l}`);const S=z(l),c=a.useRef(!0);a.useEffect(()=>{const{bindI18n:s,bindI18nStore:i}=y;c.current=!0,!f&&!N&&(n.lng?I(e,n.lng,t,()=>{c.current&&p(u)}):R(e,t,()=>{c.current&&p(u)})),f&&S&&S!==l&&c.current&&p(u);function o(){c.current&&p(u)}return s&&e&&e.on(s,o),i&&e&&e.store.on(i,o),()=>{c.current=!1,s&&e&&s.split(" ").forEach(r=>e.off(r,o)),i&&e&&i.split(" ").forEach(r=>e.store.off(r,o))}},[e,l]);const b=a.useRef(!0);a.useEffect(()=>{c.current&&!b.current&&p(u),b.current=!1},[e,h]);const m=[x,e,f];if(m.t=x,m.i18n=e,m.ready=f,f||!f&&!N)return m;throw new Promise(s=>{n.lng?I(e,n.lng,t,()=>s()):R(e,t,()=>s())})}export{U as u};
